name: GitHub Feature/Release Candidate Deploy Workflow

description: Reutiliza processos de build de imagem Docker, upload de arquivos e deploy para servidores EC2, incluindo conexão via VPN.

inputs:
  AWS_ACCESS_KEY_ID:
    required: true
    description: AWS Access Key ID
  AWS_SECRET_ACCESS_KEY:
    required: true
    description: AWS Secret Key
  AWS_REGION:
    required: true
    description: AWS Region
  AWS_S3_BUCKET:
    required: false
    description: Nome do bucket S3 para baixar arquivos (se aplicável)
  ENV_FILE_PATH:
    required: false
    description: Caminho do arquivo de ambiente no S3 (se aplicável)
  ENV_ENCRYPTION_PASSWORD:
    required: false
    description: Senha de criptografia do arquivo .env
  ECR_REGISTRY:
    required: false
    description: URL do repositório ECR
  IMAGE_NAME:
    required: false
    description: Nome da imagem no ECR
  DOCKERFILE_PATH:
    required: false
    description: Caminho para o Dockerfile
  BASE_IMAGE:
    required: false
    description: Imagem base (se necessário)
  DEPLOY_FILES:
    required: false
    description: Lista de arquivos a serem empacotados para deploy
  ARTIFACT_NAME:
    required: false
    description: Nome do artefato de deploy
  RETENTION_DAYS:
    required: false
    description: Dias de retenção do artefato
    default: "1"
  SERVER_LIST:
    required: false
    description: Lista de servidores para deploy (JSON)
  SSH_USER:
    required: false
    description: Usuário SSH para deploy
  SSH_KEY_FILE:
    required: false
    description: Chave SSH para acessar os servidores
  OVPN_CONFIG_FILE:
    required: false
    description: Configuração do OpenVPN (se necessário)
  OVPN_CERT_PASS:
    required: false
    description: Senha do OpenVPN (se necessário)
  GITHUB_COMMIT:
    required: false
    description: Commit/tag para deploy
  ORIGIN:
    required: false
    description: Origem da release (fc, hotfix, etc.)
  GITHUB_TOKEN:
    required: false
    description: Token do GitHub para criar a release
  TAG:
    required: false
    description: Tag da release no GitHub
  SECRET_MANAGER_KEY:
    required: false
    description: Key do secret manager

runs:
  using: "composite"
  steps:
  - name: Configurando credenciais da AWS
    uses: aws-actions/configure-aws-credentials@v4
    with:
      aws-access-key-id: ${{ inputs.AWS_ACCESS_KEY_ID }}
      aws-secret-access-key: ${{ inputs.AWS_SECRET_ACCESS_KEY }}
      aws-region: ${{ inputs.AWS_REGION }}

  - name: Baixando arquivo .env (se aplicável)
    if: ${{ inputs.AWS_S3_ENVFILES_BUCKET != '' && inputs.ENV_FILE_PATH != '' }}
    run: |
      aws s3 cp s3://${{ inputs.AWS_S3_ENVFILES_BUCKET }}/${{ inputs.ENV_FILE_PATH }} /tmp/env
    shell: bash

  - name: Obtendo secret do Secret Manager
    if: ${{ inputs.SECRET_MANAGER_KEY != '' }}
    uses: t-botz/aws-secrets-manager-read-action@45282af736fa0ae7e0559ed105b42538344cb864
    with:
      secret-id: ${{ inputs.SECRET_MANAGER_KEY }}
      mask-json-values: true
      append-to-env-file: /tmp/env

  - name: Criptografando arquivo env com senha
    if: ${{ inputs.ENV_ENCRYPTION_PASSWORD != '' }}
    run: |
      # gpg -d --batch --passphrase "${{ inputs.ENV_ENCRYPTION_PASSWORD }}" /tmp/env.gpg > .env
      gpg -c --batch --cipher-algo AES256 --passphrase "${{ inputs.ENV_ENCRYPTION_PASSWORD }}" /tmp/env
    shell: bash

  # - name: Ajustando o env de migrations
  #   run: |
  #     cp .env .env.migrate
  #     sed -i "s/DB_USERNAME=.*//" .env.migrate
  #     sed -i "s/DB_PASSWORD=.*//" .env.migrate
  #     sed -i "s/DB_MIGRATION_USERNAME/DB_USERNAME/" .env.migrate
  #     sed -i "s/DB_MIGRATION_PASSWORD/DB_PASSWORD/" .env.migrate
  #   shell: bash

  # ##################  PUBLISH IMAGE # ##################

  - name: Baixando código do repositório
    uses: actions/checkout@v4

  - name: Adicionando Github Token ao Composer
    run: |
      cat <<-EOF > auth.json
      {
          "github-oauth": {
              "github.com": "${{ inputs.GITHUB_TOKEN }}"
          }
      }
      EOF
    shell: bash

  - name: Autenticando no ECR (se aplicável)
    if: ${{ inputs.ECR_REGISTRY != '' }}
    uses: docker/login-action@v3
    with:
      registry: ${{ inputs.ECR_REGISTRY }}

  - name: Gerando Tags e Labels para usar na imagem
    id: meta
    uses: docker/metadata-action@v4
    with:
      images: ${{ inputs.ECR_REGISTRY }}/${{ inputs.IMAGE_NAME }}
      flavor: latest=true
      tags: type=sha,format=long,prefix=

  - name: Build e Push da Imagem Docker (se aplicável)
    if: ${{ inputs.DOCKERFILE_PATH != '' }}
    uses: docker/build-push-action@v3
    with:
      context: .
      file: ${{ inputs.DOCKERFILE_PATH }}
      tags: ${{ steps.meta.outputs.tags }}
      labels: ${{ steps.meta.outputs.labels }}
      push: true
      build-args: |
        IMAGE=${{ inputs.BASE_IMAGE }}

  - name: Exportando Summary
    run: |
      echo "### Image tag :framed_picture:" >> $GITHUB_STEP_SUMMARY
      echo "$GITHUB_SHA" >> $GITHUB_STEP_SUMMARY
    shell: bash

  # ##################  DEPLOY IMAGE # ##################

  - name: Criando e Armazenando Artefato de Deploy (se aplicável)
    if: ${{ inputs.DEPLOY_FILES != '' }}
    run: |
      mkdir -p /tmp/deploy
      set -f

      for file in ${{ inputs.DEPLOY_FILES }}; do
        echo "Copiando $file para /tmp/deploy/"
        cp "$file" /tmp/deploy/ || { echo "Erro ao copiar $file"; exit 1; }
      done

      tar -czf /tmp/deploy.tar.gz -C /tmp/ deploy/
    shell: bash

  - name: Armazenando arquivo de Deploy
    uses: actions/upload-artifact@v4
    with:
      name: deploy
      path: /tmp/deploy.tar.gz
      if-no-files-found: error
      retention-days: 1

  - name: Executando Deploy nos Servidores EC2 (se aplicável)
    if: ${{ inputs.SERVER_LIST != '' }}
    run: |
      echo "Iniciando deploy nos servidores..."

      # Configuração da VPN (se necessário)
      if [[ -n "${{ inputs.OVPN_CONFIG_FILE }}" ]]; then
        echo "Instalando OpenVPN e conectando à VPN..."
        sudo apt-get update && sudo apt-get install -y openvpn
        
        echo "${{ inputs.OVPN_CERT_PASS }}" > vpn_pass.txt
        echo "${{ inputs.OVPN_CONFIG_FILE }}" > cicd.ovpn
        
        echo '${{ inputs.SERVER_LIST }}' | jq -c '.[]' | while IFS= read -r server; do
          IP=$(echo "$server" | jq -r '.ip')
          echo "route $IP 255.255.255.255" >> cicd.ovpn
        done
        
        echo "route-nopull" >> cicd.ovpn

        sudo openvpn --config cicd.ovpn --askpass vpn_pass.txt --daemon
        sleep 5

        # Verificação da VPN
        if [[ $(ip address | grep -o " tun" | wc -l) -eq 0 ]]; then
          echo "::error::Interface da VPN não encontrada!"
          exit 1
        fi
      fi

      # Criando chave SSH
      echo "Salvando chave SSH..."
      echo "${{ inputs.SSH_KEY_FILE }}" > ssh_key.pem
      chmod 600 ssh_key.pem

      # Loop para cada servidor
      for server in $(echo '${{ inputs.SERVER_LIST }}' | jq -c '.[]'); do
        NAME=$(echo $server | jq -r '.name')
        IP=$(echo $server | jq -r '.ip')

        echo "Deploy para: $NAME ($IP)"

        set -e  # Para garantir que qualquer erro interrompa a execução

        echo "Enviando arquivo de deploy para o servidor..."
        scp -o StrictHostKeyChecking=no -i ssh_key.pem /tmp/deploy.tar.gz ${{ inputs.SSH_USER }}@$IP:/tmp/

        echo "Executando comandos remotos..."
        ssh -o StrictHostKeyChecking=no -i ssh_key.pem ${{ inputs.SSH_USER }}@$IP <<EOF
          set -e
          echo "Extraindo arquivo de Deploy..."
          tar -xzf /tmp/deploy.tar.gz -C /tmp/

          echo "Carregando o GITHUB_COMMIT no env..."
          export GITHUB_COMMIT="${{ inputs.GITHUB_COMMIT }}"

          echo "Executando script de Deploy..."
          bash /tmp/deploy/up.sh

          echo "Removendo arquivos temporários..."
          rm -rf /tmp/deploy /tmp/deploy.tar.gz
        EOF

        echo "Deploy concluído para: $NAME ($IP)"
      done

      # Encerrando VPN (se aplicável)
      if [[ -n "${{ inputs.OVPN_CONFIG_FILE }}" ]]; then
        echo "Encerrando VPN..."
        sudo killall openvpn
        sleep 5
      fi
    shell: bash

  - name: Criando Release no GitHub após Deploy
    if: ${{ inputs.ORIGIN != '' && inputs.GITHUB_TOKEN != '' && inputs.TAG != '' }}
    env:
      GITHUB_TOKEN: ${{ inputs.GITHUB_TOKEN }}
    run: |
      gh auth status || exit 1
      if [[ "${{ inputs.ORIGIN }}" == "fc" ]]; then
        gh release create ${{ inputs.TAG }} --title "Release ${{ inputs.TAG }}" --notes "Release ${{ inputs.TAG }}\nCommit: $GITHUB_COMMIT" --prerelease
      elif [[ "${{ inputs.ORIGIN }}" == "hotfix" ]]; then
        gh release create ${{ inputs.TAG }} --title "Hotfix ${{ inputs.TAG }}" --notes "Hotfix ${{ inputs.TAG }}\nCommit: $GITHUB_COMMIT" --prerelease
      fi
    shell: bash
